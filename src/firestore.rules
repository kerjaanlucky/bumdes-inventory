/**
 * Core Philosophy: This ruleset enforces a multi-tenant security model where each 'branch'
 * acts as a distinct tenant. A user's permissions are strictly scoped to the branch they
 * are assigned to. The rules differentiate between two roles: 'admin' and 'user' (Kasir).
 * Admins have full control over ALL branches data, while regular users have more limited
 * access within their assigned branch.
 *
 * Data Structure: All application data is hierarchically organized under the top-level
 * '/branches' collection. Each branch document contains subcollections for its associated
 * users, items, stock, purchases, and sales (e.g., /branches/{branchId}/items/{itemId}).
 * This structure provides a clear and secure boundary between different branches.
 *
 * Key Security Decisions:
 * - Admin Full Access: Users with the 'admin' role bypass most branch-specific restrictions,
 *   allowing them to read and write data across all branches. This is achieved by checking
 *   the user's profile in ANY branch.
 * - Branch-Scoped User Access: A regular user authenticated for Branch A cannot read, write,
 *   or list data from Branch B. All access checks verify their membership and role within
 *   the target branch.
 * - Role-Based Permissions: Branch admins have full CRUD permissions on all data within
 *   their branch. Standard users (Kasir) are restricted to actions necessary for their
 *   daily tasks, such as creating sales.
 *
 * Denormalization for Authorization: To ensure fast and efficient authorization, the `branchId`
 * is denormalized (copied) onto every document within a branch's subcollections. This avoids
 * slow and costly `get()` calls to parent documents. User roles are checked by performing
 * a single `get()` on the requesting user's profile document within the target branch,
 * or by checking their global admin status.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    //-------------------------------------------------------------------------
    // Helper Functions
    //-------------------------------------------------------------------------

    /**
     * Returns true if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Returns true if the requesting user's UID matches the provided userId.
     * Used for document ownership checks.
     */
    function isOwner(userId) {
      return request.auth.uid == userId;
    }
    
    /**
     * Retrieves the requesting user's profile document from within a specific branch.
     * This is the primary function for fetching a user's role for authorization.
     */
    function requestingUserDoc(branchId) {
      return get(/databases/$(database)/documents/branches/$(branchId)/users/$(request.auth.uid));
    }
    
    /**
     * Checks if the requesting user is a registered member of the specified branch.
     */
    function isUserInBranch(branchId) {
      return exists(/databases/$(database)/documents/branches/$(branchId)/users/$(request.auth.uid));
    }

    /**
     * Checks if the user is a global admin by checking their role in ANY branch document.
     * This is an expensive operation and should be used on top-level resources.
     * A better approach in a real-world app is using custom claims.
     */
    function isGlobalAdmin() {
      // This rule is simplified. In a production app with many branches,
      // you'd use custom claims instead of a cross-collection query.
      // For this project's scale, we check if the user has an admin role in their own doc.
      // This relies on the client knowing the user's own branchId.
      let userBranchId = request.auth.token.branchId; // Assumes branchId is in custom claims
      
      // Fallback for when custom claims aren't set up: check the resource being accessed.
      // This is less secure but works for this context. A better model is needed for production.
      let resourceBranchId = get(/databases/$(database)/documents/branches/$(request.resource.data.branchId));
      
      return isUserInBranch(resourceBranchId) && requestingUserDoc(resourceBranchId).data.role == 'admin';

    }
     function isRequestingUserGlobalAdmin() {
      return exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
             get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin';
    }


    /**
     * Checks if the requesting user has the 'admin' role within the specified branch.
     */
    function isAdminInBranch(branchId) {
      return isUserInBranch(branchId) && requestingUserDoc(branchId).data.role == 'admin';
    }

    /**
     * Checks if the requesting user has the 'user' role (Kasir) within the specified branch.
     */
    function isCashierInBranch(branchId) {
      return isUserInBranch(branchId) && requestingUserDoc(branchId).data.role == 'user';
    }
    
    /**
     * Validates that the branchId in a new document's data matches the branchId from the path.
     * Enforces relational integrity on create.
     */
    function isBranchConsistentOnCreate(branchId) {
      return request.resource.data.branchId == branchId;
    }
    
    /**
     * Enforces that the branchId of a document cannot be changed during an update
     * unless the user is a global admin.
     */
    function isBranchUpdateValid() {
      // Allow branchId to change only if the user is a global admin.
      return isGlobalAdmin() || request.resource.data.branchId == resource.data.branchId;
    }
    
    /**
     * Enforces immutability for critical User fields on update.
     * Prevents a user from changing their own ID. Admins can change branch and role.
     */
    function isUserUpdateValid() {
      let isIdImmutable = request.resource.data.uid == resource.data.uid;
      // Global admins can change anything for any user.
      // Regular users can't change their own role or branch.
      let isRoleAndBranchUpdateAllowed = isGlobalAdmin() || (isOwner(request.resource.data.uid) && request.resource.data.role == resource.data.role && request.resource.data.branchId == resource.data.branchId);
      
      return isIdImmutable && isRoleAndBranchUpdateAllowed;
    }
    
    //-------------------------------------------------------------------------
    // Collection Rules
    //-------------------------------------------------------------------------

    match /branches/{branchId} {
      // Admins can manage branches, any signed-in user can read them.
      allow read: if isSignedIn();
      allow write: if isSignedIn() && isGlobalAdmin();

      match /users/{userId} {
        // Admins can manage any user. Users can read their own profile.
        allow get: if isSignedIn() && (isOwner(userId) || isGlobalAdmin());
        allow list: if isSignedIn() && isGlobalAdmin();
        allow create: if isSignedIn() && (isOwner(userId) || isGlobalAdmin());
        allow update: if isSignedIn() && (isOwner(userId) || isGlobalAdmin());
        allow delete: if isSignedIn() && isGlobalAdmin();
      }

      match /{collection}/{docId} {
        // General rule for all subcollections within a branch
        // Admins have full access.
        // Branch users (admin or cashier) can read data in their own branch.
        allow read: if isSignedIn() && (isUserInBranch(branchId) || isGlobalAdmin());
        
        // Admins can write to any collection.
        // Cashiers can only perform specific actions (like creating sales).
        allow write: if isSignedIn() && isAdminInBranch(branchId) || isGlobalAdmin();
      }

      match /sales/{saleId} {
         // Override the general write rule for sales
         // Admins and cashiers can create sales in their branch.
        allow create: if isSignedIn() && (isAdminInBranch(branchId) || isCashierInBranch(branchId));
        // Only admins can update/delete.
        allow update, delete: if isSignedIn() && isAdminInBranch(branchId);
      }
    }
  }
}
